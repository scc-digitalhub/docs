{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The Digital Hub is an open-source platform for interoperability of data and services, built by integrating several open-source projects to manage, elaborate, expose and serve data through modern standards.</p> <p>This documentation is aimed at developers and illustrates examples on how to use and build on top of the Digital Hub's technologies.</p>"},{"location":"runtimes/sdk-runtimes/","title":"Digitalhub-core SDK runtime implementation","text":"<p>On the <code>digitalhub</code> sdk side, to implement a new runtime it is required to define a new package that includes:</p> <ul> <li>Function specifications, status and metadata</li> <li>One or more task specifications, status and metadata</li> <li>A run specification, status and metadata</li> <li>A runtime class that handle execution</li> <li>Registries that allow sdk to import the required objects.</li> </ul> <p>As an implementation example, we describe the creation of dbt runtime.</p>"},{"location":"runtimes/sdk-runtimes/#define-a-new-package","title":"Define a new package","text":"<p>First of all, we need to decide what runtime we want to implement. In our case, we want to create a runtime based on DBT.</p> <p>The package we create MUST be compliant with this naming convention:</p> <p><code>digitalhub_&lt;core/data/ml/ai&gt;_&lt;...&gt;</code></p> <p>According to the specific functionality of the runtime, the package can be part of one of the 4 digitalhub layer. Between the second brackets goes the name of the runtime which is the kind of the function we will implement. This is because a runtime corresponds to a function.</p> <p>In our case the package is named <code>digitalhub_data_dbt</code>.</p> <p>Is up to the developer to choose the way of installing the package. For <code>digitalhub_data_dbt</code> we use a <code>pyproject.toml</code> file for installation.</p> <pre><code>[build-system]\nrequires = [\"setuptools\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"digitalhub-data-dbt\"\nversion = \"0.2.3\"\ndescription = \"DBT runtime for DHCore\"\nreadme = \"README.md\"\nauthors = [\n    { name = \"Fondazione Bruno Kessler\", email = \"dslab@fbk.eu\" },\n    ...\n]\nlicense = { file = \"LICENSE.txt\" }\nclassifiers = [\n    \"License :: OSI Approved :: Apache Software License\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\"\n]\nkeywords = [\"data\", \"dataops\", \"kubernetes\"]\nrequires-python = \"&gt;=3.9\"\ndependencies = [\n\"digitalhub-data~=0.2\",\n]\n\n[project.optional-dependencies]\nlocal = [\n    \"dbt-postgres\",\n]\n...\n</code></pre> <p>Please note that the external dependencies for the runtime  are placed in optional dependencies. Why? Because by default we want to support remote execution through <code>kubernetes</code>. Of course, the local execution MUST have all the dependencies required by the runtime in the python environment, but the remote execution only needs the function, task and run files definition. With this strategy, we can avoid some dependencies conflict with the digitalhub-core execution environment. This means that defined function, tasks and run MUST NOT contain elements that require external library dependencies, but ONLY python standard library or digitalhub core dependencies.</p> <p>The package then requires, as bare minimum, an <code>__init__.py</code> top level file, function spec file, one or more task spec modules and a runtime module.</p> <p>The folder structure could be like this:</p> <pre><code>\u251c\u2500\u2500 pyproject.toml            # Installation file\n\u2514\u2500\u2500 digitalhub_data_dbt       # Package name\n    \u251c\u2500\u2500 entities\n    \u2502   \u251c\u2500\u2500 functions         # Function specification\n    \u2502   \u2502   \u251c\u2500\u2500 spec.py\n    \u2502   |   \u251c\u2500\u2500 status.py\n    \u2502   |   \u2514\u2500\u2500 metadata.py\n    \u2502   \u251c\u2500\u2500 tasks             # Task specification\n    \u2502   \u2502   \u251c\u2500\u2500 spec.py\n    \u2502   \u2502   \u251c\u2500\u2500 status.py\n    \u2502   \u2502   \u2514\u2500\u2500 metadata.py\n    \u2502   \u251c\u2500\u2500 runs              # Run specification\n    \u2502   \u2502   \u251c\u2500\u2500 spec.py\n    \u2502   \u2502   \u251c\u2500\u2500 status.py\n    \u2502   \u2502   \u2514\u2500\u2500 metadata.py\n    \u2502   \u2514\u2500\u2500 registries.py     # Spec and status registires\n    \u251c\u2500\u2500 runtime\n    \u2502   \u2514\u2500\u2500 runtime.py        # Runtime class definition\n    \u2514\u2500\u2500 `__init__.py`           # Init file where to put runtime registry\n</code></pre> <p>Of course, if more modules are needed, treat the runtime implementation like any other python package creation.</p>"},{"location":"runtimes/sdk-runtimes/#definition-of-function","title":"Definition of Function","text":"<p>We create three new modules in the <code>entities/functions</code> directory (spec.py, status.py and metadata.py). In the spec.py file we define a FunctionSpec object that inherits from FunctionSpec. The Spec object defines the specification of the function (e.g. reference to the code to be executed, sql query, etc.). The Params object models how the arguments must be provided (e.g. code must be a str, etc.).</p> <pre><code>\"\"\"\nDbt Function specification module.\n\"\"\"\nfrom __future__ import annotations\n\nfrom digitalhub_core.entities.functions.spec import FunctionParams, FunctionSpec\nfrom digitalhub_core.utils.exceptions import EntityError\nfrom digitalhub_core.utils.generic_utils import decode_string, encode_string\n\n\nclass FunctionSpecDbt(FunctionSpec):\n    \"\"\"\n    Specification for a Function Dbt.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: str | None = None,\n        sql: str | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Constructor.\n\n        Parameters\n        ----------\n        sql : str\n            SQL query to run inside Dbt.\n        \"\"\"\n        super().__init__(source, **kwargs)\n        if sql is None:\n            raise EntityError(\"SQL query must be provided.\")\n\n        # This is to avoid re-encoding the SQL query when\n        # it is already encoded.\n        try:\n            sql = decode_string(sql)\n        except Exception:\n            ...\n        self.sql = encode_string(sql)\n\n\nclass FunctionParamsDbt(FunctionParams):\n    \"\"\"\n    Function Dbt parameters model.\n    \"\"\"\n\n    sql: str = None\n    \"\"\"SQL query to run inside the container.\"\"\"\n</code></pre> <p>In the status.py file we define a FunctionStatus object that inherits from FunctionStatus.</p> <pre><code>\"\"\"\nDbt Function status module.\n\"\"\"\nfrom __future__ import annotations\n\nfrom digitalhub_core.entities.functions.status import FunctionStatus\n\n\nclass FunctionStatusDbt(FunctionStatus):\n    \"\"\"\n    Function Dbt status.\n    \"\"\"\n</code></pre> <p>Finally, in the metadata.py file we define a FunctionMetadata object that inherits from FunctionMetadata.</p> <pre><code>\"\"\"\nDbt Function metadata module.\n\"\"\"\nfrom __future__ import annotations\n\nfrom digitalhub_core.entities.functions.metadata import FunctionMetadata\n\nclass FunctionMetadataDbt(FunctionMetadata):\n    \"\"\"\n    Function Dbt metadata.\n    \"\"\"\n</code></pre>"},{"location":"runtimes/sdk-runtimes/#definition-of-task","title":"Definition of Task","text":"<p>Once the function specifications are defined, we can create one or more tasks associated with the function. In the case of DBT, we have only one kind of task: <code>transform</code>. Similarly to the function definition procedure, we need to define the new specifications and relative model schema.</p> <pre><code>\"\"\"\nTask Transform specification module.\n\"\"\"\nfrom __future__ import annotations\n\nfrom digitalhub_core.entities.tasks.spec import TaskParams, TaskSpec\n\n\nclass TaskSpecTransform(TaskSpec):\n    \"\"\"Task Transform specification.\"\"\"\n\n\nclass TaskParamsTransform(TaskParams):\n    \"\"\"\n    TaskParamsTransform model.\n    \"\"\"\n</code></pre> <p>Note that in the case of the transform task we do not have particular requirements for the specifications. You must do the same for status and metadata.</p>"},{"location":"runtimes/sdk-runtimes/#definition-of-run","title":"Definition of Run","text":"<p>The run is defined in the same way as the function and task.</p> <p>Run spec:</p> <pre><code>\"\"\"\nRun specification module.\n\"\"\"\nfrom __future__ import annotations\n\nfrom digitalhub_core.entities.runs.spec import RunParams, RunSpec\nfrom pydantic import BaseModel\n\n\nclass RunSpecDbt(RunSpec):\n    \"\"\"Run Dbt specification.\"\"\"\n\n    def __init__(\n        self,\n        task: str,\n        task_id: str,\n        inputs: dict | None = None,\n        outputs: dict | None = None,\n        parameters: dict | None = None,\n        local_execution: bool = False,\n        function_spec: dict | None = None,\n        transform_spec: dict | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Constructor.\n\n        Parameters\n        ----------\n        \"\"\"\n        super().__init__(task, task_id, inputs, outputs, parameters, local_execution, **kwargs)\n        self.function_spec = function_spec\n        self.transform_spec = transform_spec\n\n\nclass DataitemList(BaseModel):\n    \"\"\"Dataitem list model.\"\"\"\n\n    dataitems: list[str]\n    \"\"\"List of dataitem names.\"\"\"\n\n\nclass RunParamsDbt(RunParams):\n    \"\"\"Run Dbt parameters.\"\"\"\n\n    inputs: DataitemList\n    \"\"\"List of input dataitem names. Override RunSpec.inputs.\"\"\"\n\n    outputs: DataitemList\n    \"\"\"List of output dataitem names. Override RunSpec.outputs.\"\"\"\n\n    function_spec: dict = None\n    \"\"\"The function spec.\"\"\"\n\n    transform_spec: dict = None\n    \"\"\"The transform task spec.\"\"\"\n</code></pre> <p>Run status:</p> <pre><code>\"\"\"\nRun status module.\n\"\"\"\nfrom __future__ import annotations\n\nfrom digitalhub_core.entities.runs.status import RunStatus\nfrom digitalhub_data.entities.dataitems.crud import get_dataitem_from_key\nfrom digitalhub_data.entities.runs.results import RunResultsData\n\n\nclass RunStatusDbt(RunStatus):\n    \"\"\"\n    Run Dbt status.\n    \"\"\"\n\n    def __init__(\n        self,\n        state: str | None = None,\n        message: str | None = None,\n        results: dict | None = None,\n        outputs: dict | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Constructor.\n\n        Parameters\n        ----------\n        results : dict\n            Runtime results.\n        outputs : dict\n            Runtime entities outputs.\n        **kwargs\n            Keyword arguments.\n\n\n        See Also\n        --------\n        Status.__init__\n        \"\"\"\n        super().__init__(state, message)\n        self.results = results\n        self.outputs = outputs\n\n    def get_results(self) -&gt; dict:\n        \"\"\"\n        Get results.\n\n        Returns\n        -------\n        dict\n            The results.\n        \"\"\"\n        dataitems = self.outputs.get(\"dataitems\", [])\n        dataitem_objs = [get_dataitem_from_key(dti.get(\"id\")) for dti in dataitems]\n        return RunResultsData(dataitems=dataitem_objs)\n</code></pre>"},{"location":"runtimes/sdk-runtimes/#definition-of-runtime","title":"Definition of Runtime","text":"<p>Once the task is defined, we finally need to create the runtime object which takes care of the run building and execution. We first create a new module like digitalhub_data_dbt/runtimes/runtime.py. In this module we import the base runtime class and define the specific operation that the runtime can execute:</p> <pre><code>\"\"\"\nRuntime DBT module.\n\"\"\"\n# Imports\n\nclass RuntimeDbt(Runtime):\n    \"\"\"\n    Runtime Dbt class.\n    \"\"\"\n\n    allowed_actions = [\"transform\"]\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Constructor.\n        \"\"\"\n        super().__init__()\n        ...\n\n    def build(self, function: dict, task: dict, run: dict) -&gt; dict:\n        \"\"\"\n        Build run spec.\n\n        Parameters\n        ----------\n        function : dict\n            The function.\n        task : dict\n            The task.\n        run : dict\n            The run.\n\n        Returns\n        -------\n        dict\n            The run spec.\n        \"\"\"\n        task_kind = task.get(\"kind\").split(\"+\")[1]\n        return {\n            \"function_spec\": function.get(\"spec\", {}),\n            f\"{task_kind}_spec\": task.get(\"spec\", {}),\n            **run.get(\"spec\", {}),\n        }\n\n    def run(self, run: dict) -&gt; dict:\n        \"\"\"\n        Run function.\n\n        Parameters\n        ----------\n        run : dict\n            The run.\n\n        Returns\n        -------\n        dict\n            Status of the executed run.\n        \"\"\"\n        # Handle execution of functions\n\n    @staticmethod\n    def _get_executable(action: str) -&gt; Callable:\n        \"\"\"\n        Select function according to action.\n\n        Parameters\n        ----------\n        action : str\n            Action to execute.\n\n        Returns\n        -------\n        Callable\n            Function to execute.\n        \"\"\"\n        if action == \"transform\":\n            return transform\n        raise NotImplementedError\n</code></pre> <p>A runtime object must implement various methods.</p> <p>To the build() method we pass a dictionary representation of function, task and run. This method returns the new run specification. To the run() method we pass a run dictionary representation. This method parses the specification and determines which kind of task must be executed.</p>"},{"location":"runtimes/sdk-runtimes/#registries","title":"Registries","text":"<p>There are three registry that need to be instantiated:</p> <ul> <li>Runtime registry</li> <li>Spec registry</li> <li>Status registry</li> </ul> <p>Runtime registry goes in the package top level <code>__init__.py</code> file. The sdk uses a specific object to import the new classes. The <code>__init__.py</code> will look like this:</p> <pre><code>from digitalhub_core.runtimes.registry import RuntimeRegistry\n\nregistry = RuntimeRegistry()\nregistry.register(\"digitalhub_data_dbt.runtimes.runtime\", \"RuntimeDbt\")\n</code></pre> <p>The registries for statuses and specs are located into a registries.py file in the entities directory. It will look like this:</p> <pre><code>from __future__ import annotations\n\nfrom digitalhub_core.entities._base.spec import SpecRegistry\nfrom digitalhub_core.entities._base.status import StatusRegistry\n\nstatus_registry = StatusRegistry()\nstatus_registry.register(\"dbt\", \"digitalhub_core.entities.functions.status\", \"FunctionStatus\")\nstatus_registry.register(\"dbt+transform\", \"digitalhub_core.entities.tasks.status\", \"TaskStatus\")\nstatus_registry.register(\"dbt+run\", \"digitalhub_data_dbt.entities.runs.status\", \"RunStatusDbt\")\n\nspec_registry = SpecRegistry()\nspec_registry.register(\"dbt\", \"digitalhub_data_dbt.entities.functions.spec\", \"FunctionSpecDbt\", \"FunctionParamsDbt\")\nspec_registry.register(\n    \"dbt+transform\", \"digitalhub_data_dbt.entities.tasks.spec\", \"TaskSpecTransform\", \"TaskParamsTransform\"\n)\nspec_registry.register(\"dbt+run\", \"digitalhub_data_dbt.entities.runs.spec\", \"RunSpecDbt\", \"RunParamsDbt\")\n</code></pre>"},{"location":"tasks/rm-custom-views/","title":"KRM - Custom views","text":"<p>In Kubernetes Resource Manager, it is possible to customize the pages for creating, listing, inspecting and editing custom resources of a specific kind. As it involves writing React code, and using the React-admin library, familiarity with these technologies may be required, depending on the desired level of customization.</p>"},{"location":"tasks/rm-custom-views/#create-a-custom-view","title":"Create a custom view","text":"<p>Create a new file, under <code>frontend/src/resources</code>, containing the name of the custom resource definition (CRD), in the format <code>cr.&lt;CRD&gt;.ts</code>. For example, if the CRD is <code>myresource.example.com</code>, the filename will be <code>cr.myresource.example.com.tsx</code>.</p> <p>You are encouraged to use other files within the path as reference on how to write this file. You are expected to define 4 functions, one for each of these actions: Create, List, Show, Edit. Each would have this structure: <pre><code>const CrCreate = () =&gt; { // example for Create\n    ...\n    return (\n        &lt;&gt;\n            ...\n        &lt;/&gt;\n    );\n};\n</code></pre></p> <p>The body of the function will perform any kind of computation that your page may need, while the return segment will contain the form or datagrid to display.</p> <p>Then, register these functions within a view and export it:</p> <pre><code>const CustomView: View = {\n    key: 'myresource.example.com',\n    name: 'My Resource',\n    list: CrList,\n    show: CrShow,\n    create: CrCreate,\n    edit: CrEdit,\n};\n\nexport default CustomView;\n</code></pre>"},{"location":"tasks/rm-custom-views/#register-the-custom-view","title":"Register the custom view","text":"<p>Once the custom view file is ready, you simply need to register it. Open <code>frontend/src/App.tsx</code> and import the view:</p> <pre><code>import crExample from './resources/cr.myresource.example.com';\n</code></pre> <p>Then, register it by adding a line to the <code>customView</code> structure:</p> <pre><code>const customViews: { [index: string]: View } = {\n    'myresource.example.com': crExample,\n    ...\n};\n</code></pre>"}]}